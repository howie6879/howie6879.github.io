<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>第四部分：附录 on 机器学习之路</title>
    <link>https://www.howie6879.cn/ml_book/docs/04_appendix/</link>
    <description>Recent content in 第四部分：附录 on 机器学习之路</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language><atom:link href="https://www.howie6879.cn/ml_book/docs/04_appendix/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title></title>
      <link>https://www.howie6879.cn/ml_book/docs/04_appendix/00.%E4%B8%80%E7%AB%99%E5%BC%8F%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E4%BA%91%E7%A0%94%E5%8F%91%E5%B9%B3%E5%8F%B0/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.howie6879.cn/ml_book/docs/04_appendix/00.%E4%B8%80%E7%AB%99%E5%BC%8F%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E4%BA%91%E7%A0%94%E5%8F%91%E5%B9%B3%E5%8F%B0/</guid>
      <description>一站式机器学习云开发平台 #   本篇是关于自身在机器学习这块工作经验的思考总结
 我希望构建一个机器学习云开发平台，目标在于解决以下问题：
 团队协作：项目管理，技术&amp;amp;业务的共享如何体现在实际解决问题的过程中； 资源调度：数据处理、模型训练； 模块共享：低代码甚至无代码； 快速开发：快速试错、实践、测试、部署； 需求-&amp;gt;开发的闭环  背景 #  自17年毕业以来，我从事于游戏行业的风控领域，主要涉及的系统的是风控和画像这两块。尽管我从团队初始建立的时候就定义了各种服务模板以及脚手架，但在数据处理、模型构建、管理这块我并没有着重去管控，仅仅是设定了一些服务的标准（初始阶段需要的是快速响应需求），如今随着业务场景和团队成员的增加，有如下问题需要考虑：
 脚本模块共享问题，团队成员长期开发积累的技术脚本、模型等是否可以模块化用于给其他成员共用； 不同数据及不同模型快速试验的的效率问题，我理想的解决方案是类似工作流那样自由组合脚本，从数据提取到模型构建再到模型管控以作业流的形式来完成（这也意味着只要公有模块覆盖面足够广，就可以进行组件拖拽式开发）； 模型测试管理问题，每个模型有哪些版本？怎么快速测试？分别被哪些服务使用以及如何快速上线； 资源调度问题，公司的数据存于云商，本地开发涉及的资源问题如何解决。  一站式机器学习云研发平台 #  目标 #  上面提到的问题可能也和大数据计算领域有些交集，毕竟都涉及到了 ETL，这些问题实际上涵盖了一个数据模型从开发到上线完整的生命周期。对于上述的需求，其实我们可以分别拆开来看看会衍生出怎样的目标：
 第1、2两点在我看来可以归纳为一个问题，模块需要抽象，然后让开发者可以自由地从模块仓库选取自己需要的模块进行组合，最终形成一个从数据提取到模型构建再到模型管控的工作流；一个项目可以有多个工作流，工作流的最小元素是模块，工作流的运行参数可以自由定义，开发者可以通过调整参数来快速调优；模块（函数）即服务，组合完毕就意味着一个需求的实现； 第3点的实现离不开两个基础服务，一是模型自动API服务化，二是模型管控服务； 第4点可以从两个方向入手，引入资源管理系统，如k8s或者云商的资源管理服务。  最终目标呼之欲出了，总结下我的需求，我需要的是一个满足数据计算、训练、管理的一站式机器学习云研发平台；而这个平台具有管理一个模型生命周期且形成闭环的功能，核心功能如：
 数据的访问与计算是无限制的； 模块即服务且可多用户互相共享； 一个需求的解决方案是模块的自由组合，需求的最终产物是模型（也可以是数据）； 对于模型可配置、易管控，可自动API服务化且可快速测试上线。  对于一站式机器学习云研发平台，我们需要其具有怎样的功能已经描述的差不多，既然问题已经抛了出来，接下来就说说怎么解决。
一切事情都有很多种解决方案，随着云原生的普及，容器技术的引入，中台在国内企业的覆盖率越来越广，该有的技术和业务的基础设施都开始有了一定的积累，怎么利用这些基础设施来进一步提升开发效率是接下来的一个方向，我期望最终解决方案有如下两个特性：
  低代码（高层次人员无代码）：基于现有的基础设施（脚手架、模型代码库、模板）可以根据通用模块结合个性化配置形成工作流就可以构建一个机器学习应用，工作流为核心的低代码、甚至无代码工作方式是我的期望，那么代码谁来写？这又是一个值得深入探讨的问题，目前暂不探讨，现在就假设有底层程序员在持续奋斗；
  云开发：因为涉及到资源的调度（数据计算、模型训练等），所以一个模型从数据输入到模型输出的开发流程都可以在云端完成（特别是数据处理和模型训练），浏览器在手，天下我有。
  就目前垂直的机器学习数据科学领域，再结合最新的技术方向，我个人很看好这两块，我认为低代码、云开发是构建新一代云原生应用的新式武器！（如果一直往前走，容器技术暂且不谈，单单微服务架构是不适用于这种原生应用的构建了，目前有大佬在研究的云研发架构或许是个方向。）
流程 #  先说说低代码，这里的低代码表达的是我们实现一个模型需求的方式，也就是说我们用低代码的方式来快速实现需求。
前面提到的模块即服务，通过连接各个模块最终形成一个工作流就是一个友好的方式，这也是市面上大部分产品的实现方式；每个模块的展现形式应该是友好可定义的，然后根据输入参数的不同来展现不同的行为（比如通过DSL定义，再基于DSL构建交互式的界面进行快速低代码开发）。
前面我们强调了闭环，那么在满足低代码这种特性下，我们的开发流程是怎样的呢？
 需求分析 方案确立（文档&amp;amp;会议讨论） 组件选择（通过DSL定义） 在机器学习云平台勾选组件、进行DSL配置，形成工作流（工作流的输出就是解决方案的核心） 验证&amp;amp;验收&amp;amp;部署（业务介入）  其实和传统方式一样，低代码的核心点也要求从需求分析到部署可以形成一个独立的闭环，不过在中间开发、验收、部署的过程都尽量实现低代码。低代码带来的效率提升是肉眼可见的，而实现低代码的关键点在于技术与业务的抽象，这里的表现为模块[函数]即服务；通过组合各个函数，就可以很方便地形成一个端到端的工作流以作为对某个需求的解决方案。
再来说说云开发，在机器学习领域，计算资源是一个不可忽视的问题，特别是在大数据计算清洗以及模型训练这块，目前基本上绕不过几大云商。我的想法是数据在哪，我们的开发环境就可以在哪，结合k8s，我们可以轻松建立团队的云研发环境，比如：</description>
    </item>
    
    <item>
      <title></title>
      <link>https://www.howie6879.cn/ml_book/docs/04_appendix/01.%E8%AF%91%E5%A6%82%E4%BD%95%E7%94%A8python%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.howie6879.cn/ml_book/docs/04_appendix/01.%E8%AF%91%E5%A6%82%E4%BD%95%E7%94%A8python%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/</guid>
      <description>如何用Python创建一个简单的神经网络 #   原文地址：How to Create a Simple Neural Network in Python 作者：Dr. Michael J. Garbade 翻译：howie6879   理解神经网络如何工作的最好方式是自己动手创建一个，这篇文章将会给你演示怎么做到这一点
 神经网络(NN)，也称之为人工神经网络(ANN)，它是机器学习领域中学习算法集合中的子集，其核心概念略似生物神经网络的概念。
拥有五年以上经验的德国机器学习专家Andrey Bulezyuk说过：神经网络正在使机器学习发生革命性的巨变，因为他们能够跨越广泛的学科和行业来高效地建模复杂的抽象。
基本上，一个ANN由以下组件构成：
 输入层：接受传递数据 隐藏层 输出层 各层之间的权重 每个隐藏层都会有一个精心设计的激活函数，对于此教程，我们将会使用Sigmoid激活函数  神经网络的类型有很多，在这个项目中，我们准备创建一个前馈神经网络，此类型的ANN将会直接从前到后传递数据
训练前馈神经元往往需要反向传播，反向传播为神经网络提供了相应的输入和输出集合，输入数据在被传递到神经元的时候被处理，然后产生一个输出
下面展示了一个简单的神经网络结构图：
而且，理解神经网络如何工作做好的办法就是去学习从头开始构建一个神经网络(不使用任何第三方库，作者意思应该是不使用任何机器学习库)。
在本文中，我们将演示如何使用Python编程语言创建一个简单的神经网络。
问题 #  这里用表格列出了我们需要解决的问题：
我们将会训练一个特定的神经网络模型，当提供一组新数据的时候，使其能够准确地预测输出值。
如你在表中所见，输出值总是等于输入数据的第一个值，因此我们期望的表中输出(?)值是1。
让我们思考看看能不能使用一些Python代码来给出相同的结果(再继续阅读之前，你可以在文章末尾仔细地阅读此项目的代码)
创建一个神经网络类 #  我们将在Python中创建一个NeuralNetwork类来训练神经元以提供准确的预测，该类还具有一些其他的辅助函数
尽管我们没有使用任何一个神经网络库用于这个简单的神经网络示例，我们也会导入numpy包来协助计算。
该库带有以下四个重要方法：
 exp：用于生成自然指数 array：用于生成矩阵 dot：用于乘法矩阵 random：用于生成随机数(注意：我们将对随机数进行播种以确保其有效分布)  应用 Sigmoid 激活函数 #  该神经网络将使用Sigmoid function作为激活函数，其绘制了一个典型的S形曲线：
此函数可以将任意值映射到区间0~1之间，它将帮助我们规范化输入值的和权重乘积之和。
随后，我们将创建Sigmoid函数的导数来帮助计算机对权重进行必要的调整。
一个Sigmoid函数的输出可以用来生成它的导数，例如，如果输出变量是X，那么它的导数将是x * (1-x)。
推导过程如下：</description>
    </item>
    
    <item>
      <title></title>
      <link>https://www.howie6879.cn/ml_book/docs/04_appendix/02.%E6%A2%AF%E5%BA%A6%E4%B8%8B%E9%99%8D%E6%95%B0%E5%AD%A6%E6%8E%A8%E5%AF%BC/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.howie6879.cn/ml_book/docs/04_appendix/02.%E6%A2%AF%E5%BA%A6%E4%B8%8B%E9%99%8D%E6%95%B0%E5%AD%A6%E6%8E%A8%E5%AF%BC/</guid>
      <description>梯度下降数学推导 #  以感知器为例，可以梯度下降来学习合适的权重和偏置：
假设有n个样本，第i次的实际输出为y，对于样本的预测输出可以表示为：
$$ \bar{y}^i = w_1x_1^i+w_2x_2^i+&amp;hellip;+w_nx_n^i+b $$
任意一个样本的实际输出和预测输出单个样本的误差，可以使用MES表示：
$$ e^i=\frac{1}{2}(y^i-\bar{y}^i)^{2} $$
那么所有误差的和可以表示为：
$$ \begin{aligned} E &amp;amp;= e^1+e^2+&amp;hellip;+e^n \\ &amp;amp;= \sum_{i=1}^ne^i \\ &amp;amp;= \frac{1}{2}\sum_{i=1}^n(y^i-w^Tx^i)^2 \end{aligned} $$
梯度下降 #  想象一下，当你从山顶往下走，只要你沿着最陡峭的位置往下走，那么终将走到最底部（也可能是局部最低）：
我们学习的目的就是在$E$尽量最小，然后得到此时的$w$和$b$，前面说的最陡峭的位置该怎么定义呢？我们可以引入梯度，这是一个向量，指的是函数值上升最快的方向，那么最陡峭的位置就可以用在最陡峭的方向迈出一步（步长，学习速率），用数学公式表示为：
 其中：
 $\nabla$表示梯度算子 $\nabla f(x)$表示函数的梯度 $\eta$表示梯度、学习速率，可以理解为找准下山的方向后要迈多大步子  推导 #  现在有了目标函数，也知道怎么找到让目标函数值最小的办法，对于参数$w$： $$ E_{(w)} = \frac{1}{2}\sum_{i=1}^n(y^i-w^Tx^i)^2 $$
那么$W$值的更新公式为：
$$ w_{n e w}=w_{\text {old }}-\eta \nabla E_{(w)} $$
关键步骤来了，来看看$E_{(w)}$的推导吧：
$$ \begin{aligned} \nabla E(\mathrm{w}) &amp;amp;=\frac{\partial}{\partial \mathrm{w}} E(\mathrm{w}) \\
&amp;amp;=\frac{\partial}{\partial \mathrm{w}} \frac{1}{2} \sum_{i=1}^{n}\left(y^{(i)}-\bar{y}^{(i)}\right)^{2} \\&amp;amp;=\frac{1}{2}\frac{\partial}{\partial \mathrm{w}} \sum_{i=1}^{n} \left(y^{(i)2}-2y^{(i)}\bar{y}^{(i)}+\bar{y}^{(i)2}\right) \end{aligned} $$</description>
    </item>
    
  </channel>
</rss>
